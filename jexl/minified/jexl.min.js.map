{"version":3,"file":"jexl.min.js","sources":["../dist/Jexl.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\n/*\n * Jexl\n * Copyright 2020 Tom Shawver\n */\nvar Expression = require('./Expression');\n\nvar _require = require('./grammar'),\n    getGrammar = _require.getGrammar;\n/**\n * Jexl is the Javascript Expression Language, capable of parsing and\n * evaluating basic to complex expression strings, combined with advanced\n * xpath-like drilldown into native Javascript objects.\n * @constructor\n */\n\n\nvar Jexl = /*#__PURE__*/function () {\n  function Jexl() {\n    (0, _classCallCheck2.default)(this, Jexl);\n    // Allow expr to be called outside of the jexl context\n    this.expr = this.expr.bind(this);\n    this._grammar = getGrammar();\n  }\n  /**\n   * Adds a binary operator to Jexl at the specified precedence. The higher the\n   * precedence, the earlier the operator is applied in the order of operations.\n   * For example, * has a higher precedence than +, because multiplication comes\n   * before division.\n   *\n   * Please see grammar.js for a listing of all default operators and their\n   * precedence values in order to choose the appropriate precedence for the\n   * new operator.\n   * @param {string} operator The operator string to be added\n   * @param {number} precedence The operator's precedence\n   * @param {function} fn A function to run to calculate the result. The function\n   *      will be called with two arguments: left and right, denoting the values\n   *      on either side of the operator. It should return either the resulting\n   *      value, or a Promise that resolves with the resulting value.\n   * @param {boolean} [manualEval] If true, the `left` and `right` arguments\n   *      will be wrapped in objects with an `eval` function. Calling\n   *      left.eval() or right.eval() will return a promise that resolves to\n   *      that operand's actual value. This is useful to conditionally evaluate\n   *      operands.\n   */\n\n\n  (0, _createClass2.default)(Jexl, [{\n    key: \"addBinaryOp\",\n    value: function addBinaryOp(operator, precedence, fn, manualEval) {\n      this._addGrammarElement(operator, (0, _defineProperty2.default)({\n        type: 'binaryOp',\n        precedence: precedence\n      }, manualEval ? 'evalOnDemand' : 'eval', fn));\n    }\n    /**\n     * Adds or replaces an expression function in this Jexl instance.\n     * @param {string} name The name of the expression function, as it will be\n     *      used within Jexl expressions\n     * @param {function} fn The javascript function to be executed when this\n     *      expression function is invoked. It will be provided with each argument\n     *      supplied in the expression, in the same order.\n     */\n\n  }, {\n    key: \"addFunction\",\n    value: function addFunction(name, fn) {\n      this._grammar.functions[name] = fn;\n    }\n    /**\n     * Syntactic sugar for calling {@link #addFunction} repeatedly. This function\n     * accepts a map of one or more expression function names to their javascript\n     * function counterpart.\n     * @param {{}} map A map of expression function names to javascript functions\n     */\n\n  }, {\n    key: \"addFunctions\",\n    value: function addFunctions(map) {\n      for (var key in map) {\n        this._grammar.functions[key] = map[key];\n      }\n    }\n    /**\n     * Adds a unary operator to Jexl. Unary operators are currently only supported\n     * on the left side of the value on which it will operate.\n     * @param {string} operator The operator string to be added\n     * @param {function} fn A function to run to calculate the result. The function\n     *      will be called with one argument: the literal value to the right of the\n     *      operator. It should return either the resulting value, or a Promise\n     *      that resolves with the resulting value.\n     */\n\n  }, {\n    key: \"addUnaryOp\",\n    value: function addUnaryOp(operator, fn) {\n      this._addGrammarElement(operator, {\n        type: 'unaryOp',\n        weight: Infinity,\n        eval: fn\n      });\n    }\n    /**\n     * Adds or replaces a transform function in this Jexl instance.\n     * @param {string} name The name of the transform function, as it will be used\n     *      within Jexl expressions\n     * @param {function} fn The function to be executed when this transform is\n     *      invoked. It will be provided with at least one argument:\n     *          - {*} value: The value to be transformed\n     *          - {...*} args: The arguments for this transform\n     */\n\n  }, {\n    key: \"addTransform\",\n    value: function addTransform(name, fn) {\n      this._grammar.transforms[name] = fn;\n    }\n    /**\n     * Syntactic sugar for calling {@link #addTransform} repeatedly.  This function\n     * accepts a map of one or more transform names to their transform function.\n     * @param {{}} map A map of transform names to transform functions\n     */\n\n  }, {\n    key: \"addTransforms\",\n    value: function addTransforms(map) {\n      for (var key in map) {\n        this._grammar.transforms[key] = map[key];\n      }\n    }\n    /**\n     * Creates an Expression object from the given Jexl expression string, and\n     * immediately compiles it. The returned Expression object can then be\n     * evaluated multiple times with new contexts, without generating any\n     * additional string processing overhead.\n     * @param {string} expression The Jexl expression to be compiled\n     * @returns {Expression} The compiled Expression object\n     */\n\n  }, {\n    key: \"compile\",\n    value: function compile(expression) {\n      var exprObj = this.createExpression(expression);\n      return exprObj.compile();\n    }\n    /**\n     * Constructs an Expression object from a Jexl expression string.\n     * @param {string} expression The Jexl expression to be wrapped in an\n     *    Expression object\n     * @returns {Expression} The Expression object representing the given string\n     */\n\n  }, {\n    key: \"createExpression\",\n    value: function createExpression(expression) {\n      return new Expression(this._grammar, expression);\n    }\n    /**\n     * Retrieves a previously set expression function.\n     * @param {string} name The name of the expression function\n     * @returns {function} The expression function\n     */\n\n  }, {\n    key: \"getFunction\",\n    value: function getFunction(name) {\n      return this._grammar.functions[name];\n    }\n    /**\n     * Retrieves a previously set transform function.\n     * @param {string} name The name of the transform function\n     * @returns {function} The transform function\n     */\n\n  }, {\n    key: \"getTransform\",\n    value: function getTransform(name) {\n      return this._grammar.transforms[name];\n    }\n    /**\n     * Asynchronously evaluates a Jexl string within an optional context.\n     * @param {string} expression The Jexl expression to be evaluated\n     * @param {Object} [context] A mapping of variables to values, which will be\n     *      made accessible to the Jexl expression when evaluating it\n     * @returns {Promise<*>} resolves with the result of the evaluation.\n     */\n\n  }, {\n    key: \"eval\",\n    value: function _eval(expression) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var exprObj = this.createExpression(expression);\n      return exprObj.eval(context);\n    }\n    /**\n     * Synchronously evaluates a Jexl string within an optional context.\n     * @param {string} expression The Jexl expression to be evaluated\n     * @param {Object} [context] A mapping of variables to values, which will be\n     *      made accessible to the Jexl expression when evaluating it\n     * @returns {*} the result of the evaluation.\n     * @throws {*} on error\n     */\n\n  }, {\n    key: \"evalSync\",\n    value: function evalSync(expression) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var exprObj = this.createExpression(expression);\n      return exprObj.evalSync(context);\n    }\n    /**\n     * A JavaScript template literal to allow expressions to be defined by the\n     * syntax: expr`40 + 2`\n     * @param {Array<string>} strs\n     * @param  {...any} args\n     */\n\n  }, {\n    key: \"expr\",\n    value: function expr(strs) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      var exprStr = strs.reduce(function (acc, str, idx) {\n        var arg = idx < args.length ? args[idx] : '';\n        acc += str + arg;\n        return acc;\n      }, '');\n      return this.createExpression(exprStr);\n    }\n    /**\n     * Removes a binary or unary operator from the Jexl grammar.\n     * @param {string} operator The operator string to be removed\n     */\n\n  }, {\n    key: \"removeOp\",\n    value: function removeOp(operator) {\n      if (this._grammar.elements[operator] && (this._grammar.elements[operator].type === 'binaryOp' || this._grammar.elements[operator].type === 'unaryOp')) {\n        delete this._grammar.elements[operator];\n      }\n    }\n    /**\n     * Adds an element to the grammar map used by this Jexl instance.\n     * @param {string} str The key string to be added\n     * @param {{type: <string>}} obj A map of configuration options for this\n     *      grammar element\n     * @private\n     */\n\n  }, {\n    key: \"_addGrammarElement\",\n    value: function _addGrammarElement(str, obj) {\n      this._grammar.elements[str] = obj;\n    }\n  }]);\n  return Jexl;\n}();\n\nmodule.exports = new Jexl();\nmodule.exports.Jexl = Jexl;"],"names":["_interopRequireDefault","require","_defineProperty2","_classCallCheck2","_createClass2","Expression","getGrammar","Jexl","default","this","expr","bind","_grammar","key","value","operator","precedence","fn","manualEval","_addGrammarElement","type","name","functions","map","weight","Infinity","eval","transforms","expression","createExpression","compile","context","arguments","length","undefined","evalSync","strs","_len","args","Array","_key","exprStr","reduce","acc","str","idx","elements","obj","module","exports"],"mappings":"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"}